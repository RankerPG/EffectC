# EffectC++

> 읽으면서 몰랐던 부분 정리

# 2019.11.04
<code> ~ page 51 </code>

# 2019.11.05
<code> ~ page 80 </code>

## Chapter 1
### Item 3 : 낌새만 보이면 const를 들이대보자.
*****
- const vector::iterator = 상수 반복자
- vector::const_iterator = 상수 데이터

- 물리적 상수성은 멤버 변수가 1비트라도 변경되면 안된다.
- 논리적 상수성은 내부적으로 바뀌어도 사용자가 모르면 상수성이 유지된다라고 말함.

- mutable 키워드 : 물리적 상수성을 무시한다.

### Item 4 : 객체를 사용하기 전에 반드시 그 객체를 초기화하자
*****
- 비지역 정적 객체는 함수에서 정의하지 않는 정적 객체로 초기화 순서를 지정할 수 없다.
그래서 함수 내부에 넣어 정의하여 비지역 정적 객체를 지역 정적 객체로 바꿔 사용해야 초기화되지 않은 객체에 접근하는 경우를 막을 수 있다.
이 방법을 이용한 패턴이 싱글턴 패턴이다.

- 멀티 쓰레드 환경에서 비상수 정적 변수는 시한폭탄과 같다. 그래서 다중쓰레드 시동전에 미리 초기화를 다 끝내 경쟁 상태(race condition)을 막을 수 있다.
- 경쟁 상태 : 전산학에서 경쟁 상태란 공유 자원에 대해 여러 개의 프로세스가 동시에 접근을 시도할 때 접근의 타이밍이나 순서 등이 결과값에 영향을 줄 수 있는 상태를 말한다. 동시에 접근할 때 자료의 일관성을 해치는 결과가 나타날 수 있다. 이를 방지하기 위해서는 프로세스 협력 기법이 필요하다.

# 2019.11.06
<code> ~ page  </code>

## Chapter 2 - 생성자 소멸자 및 대입 연산자

### Item 5 : C++가 은글슬쩍 만들어 호출해 버리는 함수들에 촉각을 세우자
*****

### Item 6 : 컴파일러가 만들어낸 함수가 필요 없으면 확실히 이들의 사용을 금해 버리자
*****
> 복사를 막을 클래스 구현
- 복사 생성자와 복사 대입 연산자를 private으로 하여 외부 복사 방지
- 복사 생성자와 복사 대입 연산자를 private으로 만든 클래스를 상속 받기 (부스트의 noncopyable 클래스를 상속받는 경우)
- 복사 생성자와 복사 대입 연산자를 delete 키워드로 삭제 ( 책에는 안나오지만 가장 좋은 방법 같음 )

### Item 7 : 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자
*****
- vtbl : virtual table ( 가상 함수 테이블 )
- vptr : virtual table pointer ( 가상 함수 테이블 포인터 )
- 기본클래스로서 다형성을 가진다면 가상 소멸자를 사용한다.

### Item 8 : 예외가 소멸자를 떠나지 못하도록 붙들어 놓자
*****
- 소멸자에서 예외가 발생하면 프로그램을 종료하거나 예외를 삼키는 방법밖에 없어 예외가 발생할만한 요소를 함수로 빼서 사용자가
이용할 수 있게끔 하여 예외에 대한 대응을 할 수 있게 한다.

### Item 9 : 객체 생성 및 소멸 과정 중에는 절대로 가상 함수를 호출하지 말자
*****
- **초기화되지 않은 데이터 멤버는 정의되지 않은 상태에 있다**
- 생성자 혹은 소멸자에 가상 함수를 넣으면 미정의 행동이 발생할 수 있다. 
<pre>
parent()
{
  func();
}
virtual func();

child()
: parent()
{
  func();
}
virtual func();
</pre>
> 위의 상황의 경우 부모 생성자의 func은 부모 클래스의 함수가 호출된다.

- 가상 함수가 생성자에 필요할 경우
1. 가상 함수를 비가상 함수로 만듬 ( ex : 부모 생성자에서 함수 호출에 필요한 값을 받아 함수를 호출한다. ) <br>
2. 함수 호출 클래스를 명시하여 사용

### Item 10 : 대입 연산자는 [*]this의 참조자를 반환하게 하자







